const Emitter = require('events')
const assert = require('assert')

const debug = require('debug')('cella-client')
const RStream = require('rstream')

const pkgInfo = require('./package.json')
const NotImplementedError = require('./src/errors')

const MESSAGE_TYPE = {
	NEWS: 'news',
	VOICE: 'voice',
	IMAGE: 'image',
	TEXT: 'text',
	LOCATION: 'LOCATION',
	EVENT: 'event',
}

/**
 * Expose `CellaClient` class.
 * Inherits from `Emitter.prototype`
 */

module.exports = class CellaClient extends Emitter {

	/**
	 * Initialize a new `CellaClient`.
	 *
	 * @param {Object} option
	 * @api public
	 */

	constructor(option) {
		super()

		if ('object' == typeof option) {
			this.token = option.token
			this.rstreamAddr = option.server
			this.rstream = isNullOrEmptyObject(option.rstream) ? undefined : option.rstream
		} else {
			this.token = option
			this.rstreamAddr = 'ws://stream.cella.xyz'
		}

		assert(this.token, 'Token can not be null')

		this.version = pkgInfo.version

		if (!this.rstream) {
			this.rstream = new RStream({
				server: this.rstreamAddr,
				token: this.token,
			})
		}

		assert(this.rstream, 'option.rstream not work')

		this.bindEventToStream(this.rstream)

		process.nextTick(_ => {
			this.rstream.open()
			debug(`Start listening by token: ${this.token}`)
		})
	}

	/**
	 * Initialize a new RStream
	 *
	 * @api private
	 */

	bindEventToStream(rstream) {
		rstream.on('connect_error', err => {
			debug('RStream connect_error', err)
			this.emit('connect_error', err)
		})

		rstream.on('error', err => {
			debug('rstrea.onError', err)
			this.emit('error', err)
		})

		rstream.on('message', this.handleRawMsg.bind(this))

		rstream.on('connect', _ => {
			debug('RStream connected')
			this.emit('connect')
		})
	}

	/**
	 * Close stream
	 *
	 * @api public
	 */

	close() {
		this.rstream.close()
	}

	/**
	 * Open stream
	 *
	 * @api public
	 */

	open() {
		this.rstream.open()
	}

	/**
	 * Process raw message
	 *
	 * @param {Object} message
	 * @api private
	 */

	handleRawMsg(rawMsg) {
		try {
			const msg = {
				platform: 'wechat',
				id: rawMsg.id,
				type: rawMsg.body.MsgType,
				userId: rawMsg.body.FromUserName,
				userProfile: rawMsg.body.UserProfile || {},
				to: rawMsg.to,
				createTime: rawMsg.body.CreateTime,
				body: rawMsg.body,
			}

			delete msg.body.UserProfile

			if ('event' === msg.type && 'LOCATION' === msg.body.Event) {
				msg.type = 'location_report'
			}

			if ('text' === msg.type && msg.body.Content == '【收到不支持的消息类型，暂无法显示】') {
				msg.type = 'wechat_not_support'
			}

			this.emit('rawMessage', rawMsg)
			this.emit('message', msg)
		} catch (err) {
			this.emit('error', { errdes: 'malformed message', rawMsg, err })
		}
	}

	/**
	 * sendMessage
	 *
	 * @param {String} toUser - WeChat user OpenID
	 * @param {MESSAGE_TYPE} msgType
	 * @param {Object} msgBody
	 * @api private
	 */

	sendMessage(toUser, msgType, msgBody) {
		const respond_body = {
			touser: toUser,
			msgtype: msgType,
		}

		respond_body[msgType] = msgBody

		const respond = {
			to: 'cella-wx-touch-svc-token',
			body: respond_body,
		}

		debug('sendMessage', respond)
		this.rstream.sendMessage(respond)
	}

	/**
	 * sendTextMessage
	 *
	 * @param {String} toUser - user's Wechat OpenID
	 * @param {String} text
	 * @api public
	 */

	sendTextMessage(toUser, text) {
		const respond = {
			content: text,
		}

		this.sendMessage(toUser, MESSAGE_TYPE.TEXT, respond)
	}

	/**
	 * sendImageMessage
	 *
	 * @param {String} toUser - user's Wechat OpenID
	 * @param {String} mediaId
	 * @api public
	 */

	sendImageMessage(toUser, mediaId) {
		const respond = {
			media_id: mediaId,
		}
		this.sendMessage(toUser, MESSAGE_TYPE.IMAGE, respond)
	}

	/**
	 * sendVoiceMessage
	 *
	 * @param {String} toUser - user's Wechat OpenID
	 * @param {String} mediaId
	 * @api public
	 */

	sendVoiceMessage(toUser, mediaId) {
		const respond = {
			media_id: mediaId,
		}
		this.sendMessage(toUser, MESSAGE_TYPE.VOICE, respond)
	}

	/**
	 * sendVideoMessage
	 *
	 * @param {String} toUser - user's Wechat OpenID
	 * @param {String} mediaId
	 * @api public
	 */

	sendVideoMessage(toUser, mediaId) {
		// WeChat not support this kind of request good, we'll implement this later.
		// ```
		// { errcode: 45161
		// , errmsg: this video id must be generated by calling upload api
		//
		throw new NotImplementedError('sendVideoMessage')
	}

	/**
	 * sendArticleMessage
	 *
	 * @param {String} toUser - user's Wechat OpenID
	 * @param {Object} articles - an article array of article object
	 * @api public
	 */

	sendArticleMessage(toUser, articles) {
		let respond = {
			articles,
		}

		if (!isArray(articles)) {
			respond = {
				articles: [
					articles,
				],
			}
		}

		this.sendMessage(toUser, MESSAGE_TYPE.NEWS, respond)
	}
}

/**
 * Determine if an object is Array
 *
 * @param {Object} obj
 * @api private
 */

function isArray(obj) {
	return (!!obj) && (obj.constructor === Array)
}

/**
 * Determine if an object is empty
 *
 * @param {Object} obj
 * @return {Boolen} if object is empt
 * @api private
 */

function isNullOrEmptyObject(obj) {
	if (!obj)	return true
  return !Object.keys(obj).length
}
